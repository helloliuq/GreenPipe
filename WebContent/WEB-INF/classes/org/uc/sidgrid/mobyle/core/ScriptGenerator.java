package org.uc.sidgrid.mobyle.core;

import java.io.File;
import java.util.Hashtable;
import java.util.List;
import java.util.ArrayList;

import org.antlr.stringtemplate.*;
import org.uc.sidgrid.mobyle.ProgramDocument;
import org.uc.sidgrid.mobyle.core.CmdGenerator;
/**
 * this class contains methods to create swift scripts based on application's xml and user's input
 * dependency: 1) the template for generating swift scripts 2) mobyle schema
 * @author wenjun wu
 *
 */
public class ScriptGenerator {
	/**
	 * build a swift script given the programDoc and a list of args generated by buildLocalCmd of CmdGenerator
	 * @param programDoc -- mobyle xml parser object
	 * @param margs -- an argument object list for the application command
	 * @return
	 */
	public static String buildSwiftScript(ProgramDocument programDoc, java.util.ArrayList<Argument> margs, 
		      String templateDir){
		return buildSwiftScript(programDoc, margs,templateDir, "swift");
	}
	/**
	 * build a swift script to run multiple input files and generate multiple output files
	 * both buildSwiftScript and buildSwiftFilesScript can be merged because they share a lot of codes
	 * @param programDoc
	 * @param margs 
	 * @param templateDir -- the directory path where the StringTemplate for generating the swift script can be found
	 * @return
	 */
	public static String buildSwiftFilesScript(ProgramDocument programDoc, java.util.ArrayList<Argument> margs, String templateDir){
		/**
		 * swift-file-list2 template has "fixed_array_mapper"
		 * can we support other mappers such as regexp-mapper, csv-mapper or even external mapper(?)
		 */
		StringTemplate script = prepareScript(programDoc, margs,templateDir, "swift-file-list2");
		//TODO: we should know which input argument can be looped
		script.setAttribute("Foreach", false);
		for(Argument tmp: margs){
			String value = tmp.getValue();
			if (tmp.isloop && tmp.isinput){
				String [] inputs = value.split(" ");
				if (inputs.length>1){
				  Argument looparg = new Argument(tmp.getType(), tmp.getName(), tmp.getValue());
				  script.setAttribute("LoopArg", looparg);
				  script.setAttribute("Foreach", true);
				  break;
				} 
			} 
			//TODO: check the value for each argument
			//if the argument.value has multipe inputs (seperately by blanks) or pattern file expression
			//like (?,*), we need to choose different file mappers for this argument 
			
			// when to set the loop(?)
			// when there are multiple inputs on an argument that is not tagged as 'multiple'
		}
		return script.toString();
	}
	/**
	 * build a swift script using the template on the input argument list
	 * @param programDoc: the parsed DOM-tree of the mobyle application
	 * @param margs: the input argument list
	 * @param templateDir:  the location where the template files can be found
	 * @param templateName: the name of the template file
	 * @return
	 */
	public static String buildSwiftScript(ProgramDocument programDoc, java.util.ArrayList<Argument> margs, 
			      String templateDir, String templateName){
		 StringTemplateGroup group = new StringTemplateGroup("myGroup", templateDir);
	     StringTemplate script = group.getInstanceOf(templateName);
	     script.setAttribute("application", programDoc.getProgram().getHead().getName());
	     String command = programDoc.getProgram().getHead().getCommand().newCursor().getTextValue();
	     script.setAttribute("command", command );
	     //(1) define the file type for the swift script
	     List<String> typedeflist = new ArrayList<String>();
	     for(Argument marg : margs){
	    	 String type = marg.getType();
	    	 if (!typedeflist.contains(type)){
	    		 typedeflist.add(type);
	    	 }
	     }
	     script.setAttribute("typedeflist", typedeflist);
	     //(1) define the list of output arguments
	     List<Argument> outArgs = new ArrayList<Argument>();
	     for(Argument marg : margs){
	    	 if (marg.getOut()){
	    		 outArgs.add(marg);
	    	 }
	     }
	     script.setAttribute("outArgs", outArgs);
	     //(2) define the list of input arguments
	     List<Argument> inArgs = new ArrayList<Argument>();
	     for(Argument marg : margs){
	    	 if (marg.getInput()){
	    		 inArgs.add(marg);
	    	 }
	     }
	     script.setAttribute("inArgs", inArgs);
	     //(3) define the command line
	     List<String> Args = new ArrayList<String>();
	     for(Argument marg : margs){
	    	 // some hack needed for running swift
	    	 // for any other like "-i" we should put a quote on it
	    	 Args.add(marg.getCmdLine());
	     }
	     script.setAttribute("CmdArgs", Args);
	     //(4) define the file mapping
	     List<Argument> filemapping = new ArrayList<Argument>();
	     for(Argument marg : margs){
	    	 if (marg.getOut() || marg.getInput()){
	    		 filemapping.add(marg);
	    	 }
	     }
	     script.setAttribute("inoutArgs", filemapping);
	     return script.toString();
	}
	/**
	 * build a SIDGrid swift script that can import the results back to the SIDGrid DataRepository
	 * The difference between this function and general script builder is that it needs to add a uploader component to the 
	 * generated script
	 * @param expId
	 * @param expName
	 * @param programDoc
	 * @param margs
	 * @param templateDir
	 * @return
	 */
	public static String buildSIDGridSwiftScript(int expId, String expName,
			ProgramDocument programDoc, java.util.ArrayList<Argument> margs, String templateDir){
		String genscript = buildSwiftScript(programDoc, margs, templateDir);
		StringTemplateGroup group = new StringTemplateGroup("myGroup", templateDir);
	    StringTemplate uploadTemplate = group.getInstanceOf("swift-sidgridupload");
	    uploadTemplate.setAttribute("expid", expId);
	    uploadTemplate.setAttribute("expName", expName);
        // define the list of output arguments
	     List<Argument> outArgs = new ArrayList<Argument>();
	     for(Argument marg : margs){
	    	 if (marg.getOut()){
	    		 outArgs.add(marg);
	    	 }
	     }
	    uploadTemplate.setAttribute("outArgs", outArgs);
	    genscript += "\n"+uploadTemplate.toString();
	    return genscript;
	}
	private static StringTemplate prepareScript(ProgramDocument programDoc, java.util.ArrayList<Argument> margs, 
		      String templateDir, String templateName){
		StringTemplateGroup group = new StringTemplateGroup("myGroup", templateDir);
	     StringTemplate script = group.getInstanceOf(templateName);
	     script.setAttribute("application", programDoc.getProgram().getHead().getName());
	     //(1) define the file type for the swift script
	     List<String> typedeflist = new ArrayList<String>();
	     for(Argument marg : margs){
	    	 String type = marg.getType();
	    	 if (!typedeflist.contains(type)){
	    		 typedeflist.add(type);
	    	 }
	     }
	     script.setAttribute("typedeflist", typedeflist);
	     //(1) define the list of output arguments
	     List<Argument> outArgs = new ArrayList<Argument>();
	     for(Argument marg : margs){
	    	 if (marg.getOut()){
	    		 outArgs.add(marg);
	    	 }
	     }
	     script.setAttribute("outArgs", outArgs);
	     //(2) define the list of input arguments
	     List<Argument> inArgs = new ArrayList<Argument>();
	     for(Argument marg : margs){
	    	 if (marg.getInput()){
	    		 inArgs.add(marg);
	    	 }
	     }
	     script.setAttribute("inArgs", inArgs);
	     //(3) define the command line
	     List<String> Args = new ArrayList<String>();
	     for(Argument marg : margs){
	    	 // some hack needed for running swift
	    	 // for any other like "-i" we should put a quote on it
	    	 Args.add(marg.getCmdLine());
	     }
	     script.setAttribute("CmdArgs", Args);
	     //(4) define the file mapping
	     List<Argument> filemapping = new ArrayList<Argument>();
	     for(Argument marg : margs){
	    	 if (marg.getOut() || marg.getInput()){
	    		 filemapping.add(marg);
	    	 }
	     }
	     script.setAttribute("inoutArgs", filemapping);
	     return script;
	}
	public static void main(String[] args) throws Exception{
		 File xmlFile = new File("./mobylexml/clustalw-multialign.xml"); 
		 Hashtable<String,String> valuePairs = new Hashtable<String,String>();
	     valuePairs.put("infile", "input");
	     valuePairs.put("quicktree", "slow");
	     valuePairs.put("outfile", "output");
	     
	     ProgramDocument programDoc = ProgramDocument.Factory.parse(xmlFile);
	     java.util.ArrayList<Argument> margs = new java.util.ArrayList<Argument>();
	     CmdGenerator.buildLocalCmd(programDoc, valuePairs, margs);
	     String script = buildSwiftScript(programDoc, margs, "./mobylexml");
	     System.out.println(script);
	}
}
